<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnalyticsService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tinyurl</a> &gt; <a href="index.source.html" class="el_package">com.example.tinyurl.service</a> &gt; <span class="el_source">AnalyticsService.java</span></div><h1>AnalyticsService.java</h1><pre class="source lang-java linenums">package com.example.tinyurl.service;

import com.example.tinyurl.entity.CustomUrlCode;
import com.example.tinyurl.entity.ShortUrlClickAnalytics;
import com.example.tinyurl.entity.ShortUrlClickAnalyticsId;
import com.example.tinyurl.repository.CustomUrlCodeRepository;
import com.example.tinyurl.repository.ShortUrlClickAnalyticsRepository;
import com.example.tinyurl.util.Base62Util;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveHashOperations;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class AnalyticsService {

    private final @Qualifier(&quot;reactiveStringRedisTemplate&quot;) ReactiveRedisTemplate&lt;String, String&gt; redisTemplate;
    private final CustomUrlCodeRepository customUrlCodeRepository;
    private final ShortUrlClickAnalyticsRepository analyticsRepository;

    @Value(&quot;${analytics.time.key.format:year.month.day.hour}&quot;)
    private String timeKeyFormat;

    /**
     * Captures a click event for analytics
     * Updates a Redis hash with key as `analytics:t_key`, field as `shortUrl`, and increments the value
     * This method is async and fire-and-forget - it doesn't block the calling thread
     * 
     * @param shortUrl The short URL code (e.g., &quot;_abc123&quot; or &quot;customCode&quot;)
     * @param timestamp The timestamp of the click event
     */
    public void click(String shortUrl, OffsetDateTime timestamp) {
<span class="fc" id="L44">        String tKey = generateTimeKey(timestamp);</span>
<span class="fc" id="L45">        String redisKey = &quot;analytics:&quot; + tKey;</span>
        
<span class="fc" id="L47">        ReactiveHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.opsForHash();</span>
        
        // Increment the count for this shortUrl in the hash
        // HINCRBY analytics:t_key shortUrl 1
        // Fire and forget - subscribe on a separate scheduler and don't block
<span class="fc" id="L52">        hashOps.increment(redisKey, shortUrl, 1L)</span>
<span class="fc" id="L53">            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L54">            .subscribe(</span>
                count -&gt; {
                    // Successfully incremented - analytics captured
<span class="fc" id="L57">                },</span>
                error -&gt; {
                    // Log error but don't fail the request
                    // In production, you might want to log this to a monitoring system
<span class="nc" id="L61">                }</span>
            );
<span class="fc" id="L63">    }</span>

    /**
     * Generates a time-based key (t_key) based on the configured format and timestamp
     * 
     * Format can be a combination of: year, month, day, hour, minute, seconds
     * Must be in order: year.month.day.hour.minute.seconds
     * Examples:
     * - &quot;year.month&quot; -&gt; &quot;2025.12&quot;
     * - &quot;year.month.day&quot; -&gt; &quot;2025.12.21&quot;
     * - &quot;year.month.day.hour&quot; -&gt; &quot;2025.12.21.10&quot;
     * 
     * @param timestamp The timestamp to generate the key from
     * @return The generated time key string
     */
    public String generateTimeKey(OffsetDateTime timestamp) {
<span class="fc" id="L79">        List&lt;String&gt; formatParts = Arrays.asList(timeKeyFormat.split(&quot;\\.&quot;));</span>
        
<span class="fc" id="L81">        StringBuilder keyBuilder = new StringBuilder();</span>
        
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (int i = 0; i &lt; formatParts.size(); i++) {</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (i &gt; 0) {</span>
<span class="fc" id="L85">                keyBuilder.append(&quot;.&quot;);</span>
            }
            
<span class="fc" id="L88">            String part = formatParts.get(i).trim();</span>
<span class="pc bpc" id="L89" title="2 of 7 branches missed.">            switch (part) {</span>
                case &quot;year&quot;:
<span class="fc" id="L91">                    keyBuilder.append(timestamp.getYear());</span>
<span class="fc" id="L92">                    break;</span>
                case &quot;month&quot;:
<span class="fc" id="L94">                    keyBuilder.append(String.format(&quot;%02d&quot;, timestamp.getMonthValue()));</span>
<span class="fc" id="L95">                    break;</span>
                case &quot;day&quot;:
<span class="fc" id="L97">                    keyBuilder.append(String.format(&quot;%02d&quot;, timestamp.getDayOfMonth()));</span>
<span class="fc" id="L98">                    break;</span>
                case &quot;hour&quot;:
<span class="fc" id="L100">                    keyBuilder.append(String.format(&quot;%02d&quot;, timestamp.getHour()));</span>
<span class="fc" id="L101">                    break;</span>
                case &quot;minute&quot;:
<span class="fc" id="L103">                    keyBuilder.append(String.format(&quot;%02d&quot;, timestamp.getMinute()));</span>
<span class="fc" id="L104">                    break;</span>
                case &quot;seconds&quot;:
<span class="nc" id="L106">                    keyBuilder.append(String.format(&quot;%02d&quot;, timestamp.getSecond()));</span>
<span class="nc" id="L107">                    break;</span>
                default:
                    // Unknown format part - skip it or throw exception
<span class="nc" id="L110">                    throw new IllegalArgumentException(&quot;Unknown time key format part: &quot; + part);</span>
            }
        }
        
<span class="fc" id="L114">        return keyBuilder.toString();</span>
    }

    /**
     * Parses a time key (t_key) back to a timestamp with rest as 0
     * Example: if config is &quot;year.month.day.hour&quot; and t_key is &quot;2025.12.21.10&quot;,
     * then returns &quot;2025-12-21T10:00:00Z&quot;
     * 
     * @param tKey The time key string (e.g., &quot;2025.12.21.10&quot;)
     * @return OffsetDateTime with the parsed values and rest set to 0
     */
    public OffsetDateTime parseTimeKey(String tKey) {
<span class="fc" id="L126">        List&lt;String&gt; formatParts = Arrays.asList(timeKeyFormat.split(&quot;\\.&quot;));</span>
<span class="fc" id="L127">        String[] keyParts = tKey.split(&quot;\\.&quot;);</span>
        
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (keyParts.length != formatParts.size()) {</span>
<span class="nc" id="L130">            throw new IllegalArgumentException(&quot;Time key format mismatch. Expected &quot; + formatParts.size() + &quot; parts, got &quot; + keyParts.length);</span>
        }
        
<span class="fc" id="L133">        int year = OffsetDateTime.now().getYear();</span>
<span class="fc" id="L134">        int month = 1;</span>
<span class="fc" id="L135">        int day = 1;</span>
<span class="fc" id="L136">        int hour = 0;</span>
<span class="fc" id="L137">        int minute = 0;</span>
<span class="fc" id="L138">        int second = 0;</span>
        
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (int i = 0; i &lt; formatParts.size(); i++) {</span>
<span class="fc" id="L141">            String part = formatParts.get(i).trim();</span>
<span class="fc" id="L142">            int value = Integer.parseInt(keyParts[i]);</span>
            
<span class="pc bpc" id="L144" title="2 of 7 branches missed.">            switch (part) {</span>
                case &quot;year&quot;:
<span class="fc" id="L146">                    year = value;</span>
<span class="fc" id="L147">                    break;</span>
                case &quot;month&quot;:
<span class="fc" id="L149">                    month = value;</span>
<span class="fc" id="L150">                    break;</span>
                case &quot;day&quot;:
<span class="fc" id="L152">                    day = value;</span>
<span class="fc" id="L153">                    break;</span>
                case &quot;hour&quot;:
<span class="fc" id="L155">                    hour = value;</span>
<span class="fc" id="L156">                    break;</span>
                case &quot;minute&quot;:
<span class="fc" id="L158">                    minute = value;</span>
<span class="fc" id="L159">                    break;</span>
                case &quot;seconds&quot;:
<span class="nc" id="L161">                    second = value;</span>
                    break;
            }
        }
        
<span class="fc" id="L166">        return OffsetDateTime.of(year, month, day, hour, minute, second, 0, java.time.ZoneOffset.UTC);</span>
    }

    /**
     * Resolves url_id from shortUrl code
     * If shortUrl has '_' prefix, base62 decode it
     * Otherwise, look up in custom_url_code table
     * 
     * @param shortUrl The short URL code
     * @return Mono containing the url_id, or empty if not found
     */
    public Mono&lt;Long&gt; resolveUrlId(String shortUrl) {
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (shortUrl.startsWith(&quot;_&quot;)) {</span>
            // Base62 encoded URL
            try {
<span class="fc" id="L181">                String encoded = shortUrl.substring(1); // Remove '_' prefix</span>
<span class="fc" id="L182">                long id = Base62Util.decode(encoded);</span>
<span class="fc" id="L183">                return Mono.just(id);</span>
<span class="nc" id="L184">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L185">                return Mono.empty();</span>
            }
        } else {
            // Custom URL code - look up in database
<span class="fc" id="L189">            return Mono.fromCallable(() -&gt; customUrlCodeRepository.findByCode(shortUrl))</span>
<span class="fc" id="L190">                .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L191">                .flatMap(optional -&gt; {</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                    if (optional.isPresent()) {</span>
<span class="fc" id="L193">                        CustomUrlCode customCode = optional.get();</span>
<span class="fc" id="L194">                        return Mono.just(customCode.getUrl().getId());</span>
                    } else {
<span class="nc" id="L196">                        return Mono.empty();</span>
                    }
                });
        }
    }

    /**
     * Dumps analytics data from Redis to database for a specific time key
     * After successful dump, deletes the Redis key
     * 
     * @param tKey The time key to dump (e.g., &quot;2025.12.21.10&quot;)
     * @return Mono that completes when dump is finished and key is deleted
     */
    public Mono&lt;Void&gt; dumpAnalyticsForTimeKey(String tKey) {
<span class="fc" id="L210">        String redisKey = &quot;analytics:&quot; + tKey;</span>
<span class="fc" id="L211">        ReactiveHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.opsForHash();</span>
        
        // Get all entries from the hash
<span class="fc" id="L214">        return hashOps.entries(redisKey)</span>
<span class="fc" id="L215">            .collectMap(Map.Entry::getKey, entry -&gt; {</span>
                try {
<span class="fc" id="L217">                    return Long.parseLong(entry.getValue());</span>
<span class="nc" id="L218">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L219">                    return 0L;</span>
                }
            })
<span class="fc" id="L222">            .flatMapMany(shortUrlCounts -&gt; {</span>
                // Process each shortUrl
<span class="fc" id="L224">                return Flux.fromIterable(shortUrlCounts.entrySet())</span>
<span class="fc" id="L225">                    .flatMap(entry -&gt; {</span>
<span class="fc" id="L226">                        String shortUrl = entry.getKey();</span>
<span class="fc" id="L227">                        Long count = entry.getValue();</span>
                        
                        // Resolve url_id
<span class="fc" id="L230">                        return resolveUrlId(shortUrl)</span>
<span class="fc" id="L231">                            .flatMap(urlId -&gt; {</span>
                                // Parse timestamp from t_key
<span class="fc" id="L233">                                OffsetDateTime timestamp = parseTimeKey(tKey);</span>
                                
                                // Save or update in database
<span class="fc" id="L236">                                return Mono.fromCallable(() -&gt; {</span>
<span class="fc" id="L237">                                    ShortUrlClickAnalyticsId id = new ShortUrlClickAnalyticsId(timestamp, urlId);</span>
<span class="fc" id="L238">                                    return analyticsRepository.findById(id);</span>
                                })
<span class="fc" id="L240">                                .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L241">                                .flatMap(optional -&gt; {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                                    if (optional.isPresent()) {</span>
                                        // Update existing record
<span class="nc" id="L244">                                        ShortUrlClickAnalytics existing = optional.get();</span>
<span class="nc" id="L245">                                        existing.setCount(existing.getCount() + count);</span>
<span class="nc" id="L246">                                        return Mono.fromCallable(() -&gt; analyticsRepository.save(existing))</span>
<span class="nc" id="L247">                                            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="nc" id="L248">                                            .then();</span>
                                    } else {
                                        // Create new record
<span class="fc" id="L251">                                        ShortUrlClickAnalytics analytics = new ShortUrlClickAnalytics(timestamp, urlId, count);</span>
<span class="fc" id="L252">                                        return Mono.fromCallable(() -&gt; analyticsRepository.save(analytics))</span>
<span class="fc" id="L253">                                            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L254">                                            .then();</span>
                                    }
                                });
                            })
<span class="fc" id="L258">                            .onErrorResume(e -&gt; {</span>
                                // Log error but continue processing other entries
<span class="nc" id="L260">                                return Mono.empty();</span>
                            });
                    });
            })
<span class="fc" id="L264">            .then()</span>
<span class="fc" id="L265">            .then(redisTemplate.delete(redisKey))</span>
<span class="fc" id="L266">            .then()</span>
<span class="fc" id="L267">            .onErrorResume(e -&gt; {</span>
                // Log error but don't fail the entire dump
                // Note: Key deletion happens even if some entries failed
<span class="nc" id="L270">                return Mono.empty();</span>
            });
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>