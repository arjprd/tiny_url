<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tinyurl</a> &gt; <a href="index.source.html" class="el_package">com.example.tinyurl.service</a> &gt; <span class="el_source">UserService.java</span></div><h1>UserService.java</h1><pre class="source lang-java linenums">package com.example.tinyurl.service;

import com.example.tinyurl.entity.User;
import com.example.tinyurl.model.ErrorResponse;
import com.example.tinyurl.model.LoginResponse;
import com.example.tinyurl.model.SuccessResponse;
import com.example.tinyurl.repository.UserRepository;
import com.example.tinyurl.util.AESUtil;
import com.example.tinyurl.util.CryptoUtil;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.ReactiveHashOperations;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

import java.time.Duration;
import java.util.Arrays;
import java.util.Optional;

@Service
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final ReactiveRedisTemplate&lt;String, String&gt; redisTemplate;

    @Value(&quot;${auth.aes.secret.key}&quot;)
    private String aesSecretKey;

    @Value(&quot;${auth.token.random.length:32}&quot;)
    private int tokenRandomLength;

    @Value(&quot;${auth.token.ttl:3600}&quot;)
    private long tokenTtlSeconds;

    public UserService(UserRepository userRepository,
                      PasswordEncoder passwordEncoder,
<span class="fc" id="L42">                      @Qualifier(&quot;reactiveStringRedisTemplate&quot;) ReactiveRedisTemplate&lt;String, String&gt; redisTemplate) {</span>
<span class="fc" id="L43">        this.userRepository = userRepository;</span>
<span class="fc" id="L44">        this.passwordEncoder = passwordEncoder;</span>
<span class="fc" id="L45">        this.redisTemplate = redisTemplate;</span>
<span class="fc" id="L46">    }</span>

    /**
     * Validates if the username is alphanumeric
     */
    public boolean isAlphanumeric(String username) {
<span class="pc bpc" id="L52" title="2 of 4 branches missed.">        if (username == null || username.isEmpty()) {</span>
<span class="nc" id="L53">            return false;</span>
        }
<span class="fc" id="L55">        return username.matches(&quot;^[a-zA-Z0-9]+$&quot;);</span>
    }

    /**
     * Creates a new user
     */
    public Mono&lt;CreateUserResult&gt; createUser(String username, String password) {
        // Validate username is alphanumeric
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if (!isAlphanumeric(username)) {</span>
<span class="fc" id="L64">            ErrorResponse error = new ErrorResponse(&quot;INVALID_USERNAME&quot;, &quot;Username must be alphanumeric&quot;);</span>
<span class="fc" id="L65">            return Mono.just(new CreateUserResult(null, error, HttpStatus.BAD_REQUEST));</span>
        }

        // Check if username already exists
<span class="fc" id="L69">        return Mono.fromCallable(() -&gt; userRepository.existsByUsername(username))</span>
<span class="fc" id="L70">            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L71">            .flatMap(exists -&gt; {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">                if (exists) {</span>
<span class="fc" id="L73">                    ErrorResponse error = new ErrorResponse(&quot;DUPLICATE_REQUEST&quot;, &quot;Username already exists&quot;);</span>
<span class="fc" id="L74">                    return Mono.just(new CreateUserResult(null, error, HttpStatus.CONFLICT));</span>
                }

                // Hash password with bcrypt
<span class="fc" id="L78">                String passwordHash = passwordEncoder.encode(password);</span>

                // Create and save user
<span class="fc" id="L81">                User newUser = new User(username, passwordHash);</span>
<span class="fc" id="L82">                return Mono.fromCallable(() -&gt; userRepository.save(newUser))</span>
<span class="fc" id="L83">                    .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L84">                    .map(saved -&gt; {</span>
<span class="fc" id="L85">                        SuccessResponse response = new SuccessResponse(&quot;SUCCESS&quot;, &quot;User created successfully.&quot;);</span>
<span class="fc" id="L86">                        return new CreateUserResult(response, null, HttpStatus.OK);</span>
                    });
            })
<span class="fc" id="L89">            .onErrorResume(e -&gt; {</span>
<span class="nc" id="L90">                ErrorResponse error = new ErrorResponse(&quot;SERVER_ERROR&quot;, &quot;Something went wrong&quot;);</span>
<span class="nc" id="L91">                return Mono.just(new CreateUserResult(null, error, HttpStatus.INTERNAL_SERVER_ERROR));</span>
            });
    }

    /**
     * Logs in a user and generates a token
     */
    public Mono&lt;LoginResult&gt; login(String username, String password) {
        // Validate username is alphanumeric
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (!isAlphanumeric(username)) {</span>
<span class="fc" id="L101">            ErrorResponse error = new ErrorResponse(&quot;INVALID_USERNAME&quot;, &quot;Username must be alphanumeric&quot;);</span>
<span class="fc" id="L102">            return Mono.just(new LoginResult(null, error, HttpStatus.BAD_REQUEST));</span>
        }

        // Get user by username
<span class="fc" id="L106">        return Mono.fromCallable(() -&gt; userRepository.findByUsername(username))</span>
<span class="fc" id="L107">            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L108">            .flatMap(optional -&gt; {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if (optional.isEmpty()) {</span>
<span class="fc" id="L110">                    ErrorResponse error = new ErrorResponse(&quot;UNAUTHORIZED&quot;, &quot;Invalid username or password&quot;);</span>
<span class="fc" id="L111">                    return Mono.just(new LoginResult(null, error, HttpStatus.UNAUTHORIZED));</span>
                }

<span class="fc" id="L114">                User user = optional.get();</span>
                
                // Verify password using bcrypt
<span class="fc bfc" id="L117" title="All 2 branches covered.">                if (!passwordEncoder.matches(password, user.getPasswordHash())) {</span>
<span class="fc" id="L118">                    ErrorResponse error = new ErrorResponse(&quot;UNAUTHORIZED&quot;, &quot;Invalid username or password&quot;);</span>
<span class="fc" id="L119">                    return Mono.just(new LoginResult(null, error, HttpStatus.UNAUTHORIZED));</span>
                }

                // Encrypt user.id using AES-256
<span class="fc" id="L123">                String encryptedUserId = AESUtil.encrypt(String.valueOf(user.getId()), aesSecretKey);</span>

                // Generate random crypto string
<span class="fc" id="L126">                String randomString = CryptoUtil.generateRandomString(tokenRandomLength);</span>

                // Store in Redis as hash set: key = token:&lt;user.id&gt;, field = &lt;random_string&gt;, value = &quot;true&quot;
<span class="fc" id="L129">                String redisKey = &quot;token:&quot; + user.getId();</span>
<span class="fc" id="L130">                ReactiveHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.opsForHash();</span>
                
<span class="fc" id="L132">                return hashOps.put(redisKey, randomString, &quot;true&quot;)</span>
<span class="fc" id="L133">                    .then(hashOps.expire(redisKey, Duration.ofSeconds(tokenTtlSeconds), Arrays.asList(randomString)))</span>
<span class="fc" id="L134">                    .then(Mono.fromCallable(() -&gt; {</span>
                        // Construct token: &lt;encrypted(user.id)&gt;.&lt;random_string&gt;
<span class="fc" id="L136">                        String token = encryptedUserId + &quot;.&quot; + randomString;</span>
<span class="fc" id="L137">                        return new LoginResult(new LoginResponse(token), null, HttpStatus.OK);</span>
                    }))
<span class="fc" id="L139">                    .subscribeOn(Schedulers.boundedElastic());</span>
            })
<span class="fc" id="L141">            .onErrorResume(e -&gt; {</span>
<span class="nc" id="L142">                ErrorResponse error = new ErrorResponse(&quot;SERVER_ERROR&quot;, &quot;Something went wrong&quot;);</span>
<span class="nc" id="L143">                return Mono.just(new LoginResult(null, error, HttpStatus.INTERNAL_SERVER_ERROR));</span>
            });
    }

    /**
     * Logs out a user by removing token(s) from Redis
     * Logic:
     * 1. If body.me is true, remove the current user's random key field from redis hashset token:&lt;userId&gt;
     * 2. If body.all is true, remove the whole hashset token:&lt;userId&gt;
     */
    public Mono&lt;LogoutResult&gt; logout(Long userId, String randomToken, Boolean me, Boolean all) {
<span class="fc" id="L154">        String redisKey = &quot;token:&quot; + userId;</span>
<span class="fc" id="L155">        ReactiveHashOperations&lt;String, String, String&gt; hashOps = redisTemplate.opsForHash();</span>

        Mono&lt;Void&gt; logoutOperation;

<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (Boolean.TRUE.equals(all)) {</span>
            // Remove the whole hashset
<span class="fc" id="L161">            logoutOperation = redisTemplate.delete(redisKey).then();</span>
<span class="pc bpc" id="L162" title="1 of 4 branches missed.">        } else if (Boolean.TRUE.equals(me) &amp;&amp; randomToken != null) {</span>
            // Remove the specific field from hashset
<span class="fc" id="L164">            logoutOperation = hashOps.remove(redisKey, randomToken).then();</span>
        } else {
            // No valid operation specified
<span class="fc" id="L167">            ErrorResponse error = new ErrorResponse(&quot;BAD_REQUEST&quot;, &quot;Either 'me' or 'all' must be true&quot;);</span>
<span class="fc" id="L168">            return Mono.just(new LogoutResult(null, error, HttpStatus.BAD_REQUEST));</span>
        }

<span class="fc" id="L171">        return logoutOperation</span>
<span class="fc" id="L172">            .then(Mono.fromCallable(() -&gt; {</span>
<span class="fc" id="L173">                SuccessResponse response = new SuccessResponse(&quot;LOGGED_OUT&quot;, &quot;logged out successfully&quot;);</span>
<span class="fc" id="L174">                return new LogoutResult(response, null, HttpStatus.OK);</span>
            }))
<span class="fc" id="L176">            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L177">            .onErrorResume(e -&gt; {</span>
<span class="nc" id="L178">                ErrorResponse error = new ErrorResponse(&quot;SERVER_ERROR&quot;, &quot;Something went wrong&quot;);</span>
<span class="nc" id="L179">                return Mono.just(new LogoutResult(null, error, HttpStatus.INTERNAL_SERVER_ERROR));</span>
            });
    }

    /**
     * Changes user password
     * Logic:
     * 1. Get user password hash from table
     * 2. Compare the hash of body.old_password and the db one
     * 3. If both are same, hash the new password in body.new_password and update the user's password_hash
     */
    public Mono&lt;ChangePasswordResult&gt; changePassword(Long userId, String oldPassword, String newPassword) {
        // Get user by userId
<span class="fc" id="L192">        return Mono.fromCallable(() -&gt; userRepository.findById(userId))</span>
<span class="fc" id="L193">            .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L194">            .flatMap(optional -&gt; {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">                if (optional.isEmpty()) {</span>
<span class="fc" id="L196">                    ErrorResponse error = new ErrorResponse(&quot;NOT_FOUND&quot;, &quot;User not found&quot;);</span>
<span class="fc" id="L197">                    return Mono.just(new ChangePasswordResult(null, error, HttpStatus.NOT_FOUND));</span>
                }

<span class="fc" id="L200">                User user = optional.get();</span>

                // Compare the hash of old_password and the db one
<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (!passwordEncoder.matches(oldPassword, user.getPasswordHash())) {</span>
<span class="fc" id="L204">                    ErrorResponse error = new ErrorResponse(&quot;UNAUTHORIZED&quot;, &quot;Invalid old password&quot;);</span>
<span class="fc" id="L205">                    return Mono.just(new ChangePasswordResult(null, error, HttpStatus.UNAUTHORIZED));</span>
                }

                // Hash the new password and update the user's password_hash
<span class="fc" id="L209">                String newPasswordHash = passwordEncoder.encode(newPassword);</span>
<span class="fc" id="L210">                user.setPasswordHash(newPasswordHash);</span>

<span class="fc" id="L212">                return Mono.fromCallable(() -&gt; userRepository.save(user))</span>
<span class="fc" id="L213">                    .subscribeOn(Schedulers.boundedElastic())</span>
<span class="fc" id="L214">                    .map(saved -&gt; {</span>
<span class="fc" id="L215">                        SuccessResponse response = new SuccessResponse(&quot;PASSWORD_UPDATED&quot;, &quot;password updated successfully&quot;);</span>
<span class="fc" id="L216">                        return new ChangePasswordResult(response, null, HttpStatus.OK);</span>
                    });
            })
<span class="fc" id="L219">            .onErrorResume(e -&gt; {</span>
<span class="nc" id="L220">                ErrorResponse error = new ErrorResponse(&quot;SERVER_ERROR&quot;, &quot;Something went wrong&quot;);</span>
<span class="nc" id="L221">                return Mono.just(new ChangePasswordResult(null, error, HttpStatus.INTERNAL_SERVER_ERROR));</span>
            });
    }

    // Inner class for result handling
    @lombok.Getter
    @lombok.AllArgsConstructor
    public static class CreateUserResult {
        private final SuccessResponse response;
        private final ErrorResponse error;
        private final HttpStatus status;
    }

    @lombok.Getter
    @lombok.AllArgsConstructor
    public static class LoginResult {
        private final LoginResponse response;
        private final ErrorResponse error;
        private final HttpStatus status;
    }

    @lombok.Getter
    @lombok.AllArgsConstructor
    public static class LogoutResult {
        private final SuccessResponse response;
        private final ErrorResponse error;
        private final HttpStatus status;
    }

    @lombok.Getter
    @lombok.AllArgsConstructor
    public static class ChangePasswordResult {
        private final SuccessResponse response;
        private final ErrorResponse error;
        private final HttpStatus status;
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>